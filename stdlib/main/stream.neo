import "std/array" as array;
import "std/assert";
import "std/collections/option";

proc Buffer() {
    var data;
    var full = false;

    return frozen {
        put = proc(v) {
            if full  throw "Buffer is full";
            data = v;
            full = true;
        },
        take = proc() {
            if !full  throw "Buffer is empty";
            final v = data;
            data = nil;
            full = false;
            return v;
        },
        has = proc() => full
    };
}

exported proc Stream() {
    final self = {};

    self.filter = proc(fn) {
        final s = Stream();
        final buf = Buffer();
        
        s.next = proc() {
            if !s.hasNext()  throw "next element does not exist";
            return buf.take();
        };

        s.hasNext = proc() {
            if buf.has()  return true;

            var value;
            do {
                if !self.hasNext()  return false;
                value = self.next();
            } while !fn(value);

            buf.put(value);
            return true;
        };  

        return frozen s;  
    };

    self.limit = proc(num) {
        final s = Stream();
        
        var count = 0;

        s.next = proc() {
            if !s.hasNext()  throw "next element does not exist";
            count += 1;
            return self.next();
        };

        s.hasNext = proc() {
            if !self.hasNext()  return false;
            return count < num;
        };

        return frozen s;
    };

    self.skip = proc(num) {
        final s = Stream();

        var count = 0;

        s.next = proc() {
            if !s.hasNext()  throw "next element does not exist";
            return self.next();
        };

        s.hasNext = proc() {
            while count < num && self.hasNext() {
                self.next();
                count += 1;
            }
            return count == num && self.hasNext();
        };

        return frozen s;
    };

    self.stride = proc(num) {
        final s = Stream();

        final limit = num - 1;
        assert(limit > 0);

        final buf = Buffer();
        var count = limit;

        s.next = proc() {
            if !s.hasNext()  throw "next element does not exist";
            return buf.take();
        };

        s.hasNext = proc() {
            if buf.has()  return true;

            while self.hasNext() && count < limit {
                self.next();
                count += 1;
            }

            if count == limit {
                count = 0;
                if self.hasNext()  buf.put(self.next());
                return true;
            }

            return false;
        };

        return frozen s;
    };

    self.map = proc(func) {
        final s = Stream();

        s.next = proc() => func(self.next());
        s.hasNext = self.hasNext;

        return frozen s;
    };

    self.peek = proc(func) {
        final s = Stream();

        s.next = proc() {
            final next = self.next();
            func(next);
            return next;
        };
        s.hasNext = self.hasNext;

        return frozen s;
    };

    self.distinct = proc() {
        final s = Stream();

        final buf = Buffer();
        final visited = {};

        s.next = proc() {
            if !s.hasNext()  throw "next element does not exist";
            return buf.take();
        };

        s.hasNext = proc() {
            if buf.has()  return true;
            if !self.hasNext()  return false;

            var value = self.next();
            while visited[value] != nil {
                if !self.hasNext()  return false;
                value = self.next();
            }

            visited[value] = true;
            buf.put(value);
            return true;
        };

        return frozen s;
    };

    self.sorted = proc(comparator) {
        final a = self.toArray();
        array.sort(a, comparator);
        return fromArray(a);
    };

    self.recur = proc(n) {
        final s = Stream();

        final buf = Option();
        var count = 1;

        s.next = proc() {
            if !s.hasNext()  throw "next element does not exist";
            count += 1;
            return buf.get();
        };

        s.hasNext = proc() {
            if self.hasNext() {
                if buf.has() && count < n {
                    return true;
                } else {
                    buf.set(self.next());
                    count = 0;
                    return true;
                }
            } else {
                return buf.has() && count < n;
            }
        };

        return frozen s;
    };

    self.count = proc() {
        var count = 0;

        while self.hasNext() {
            self.next();
            count += 1;
        }

        return count;
    };

    self.forEach = proc(func) {
        assert(type(func) == "procedure", "expected procedure, got " .. type(func));

        while self.hasNext()  func(self.next());
    };

    self.reduce = proc(identity, accumulator) {
        if !self.hasNext()  return Option();

        if accumulator == nil {
            accumulator = identity;
            identity = self.next();
        }

        var result = identity;

        while self.hasNext() {
            result = accumulator(result, self.next());
        }

        final ret = Option();
        ret.set(result);
        return ret;
    };

    self.findFirst = proc() {
        final ret = Option();
        if self.hasNext()  ret.set(self.next());
        return ret;
    };

    self.findLast = proc() {
        final ret = Option();
        while self.hasNext()  ret.set(self.next());
        return ret;
    };

    self.toArray = proc() {
        final a = [];
        while self.hasNext()  insert(a, self.next());
        return a;
    };

    self.min = proc(comparator) {
        if comparator == nil  comparator = array.default_comparator;
        
        final ret = Option();

        final a = self.toArray();
        if #a > 0 {
            array.sort(a, comparator);
            ret.set(a[0]);
        }

        return ret;
    };

    self.max = proc(comparator) {
        if comparator == nil  comparator = array.default_comparator;

        final ret = Option();

        final a = self.toArray();
        if #a > 0 {
            array.sort(a, comparator);
            ret.set(a[#a - 1]);
        }

        return ret;
    };

    self.anyMatch = proc(predicate) {
        while self.hasNext() {
            if predicate(self.next())  return true;
        }

        return false;
    };

    self.noneMatch = proc(predicate) {
        // NOTE TODO: Should we just say return !self.anyMatch(predicate) instead? *shrugs*

        while self.hasNext() {
            if predicate(self.next())  return false;
        }

        return true;
    };

    return self;
}

exported proc of(...) => fromArray(...)

exported proc fromArray(a) {
    if #a == 0  return empty();
    if #a == 1  return single(a[0]);

    final self = Stream();

    var index = 0;

    self.next = proc() {
        if !self.hasNext()  throw "next element does not exist";
        
        final value = a[index];
        index += 1;
        return value;
    };

    self.hasNext = proc() => index < #a;

    return frozen self;   
}

exported proc iterate(seed, func) {
    final self = Stream();

    var current = seed;
    
    self.next = proc() {
        final value = current;
        current = func(current);
        return value;
    };

    self.hasNext = proc() => true;

    return frozen self;
}

exported proc generate(func) {
    final self = Stream();

    self.next = proc() => func();
    self.hasNext = proc() => true;

    return frozen self;
}

exported proc concat(...) {
    final self = Stream();

    final streams = ...;
    var current = 0;

    self.next = proc() {
        if !self.hasNext()  throw "next element does not exist";
        final cs = streams[current];
        final result = cs.next();
        if(!cs.hasNext())  current++;
        return result;        
    };

    self.hasNext = proc() {
        if current >= #streams  return false;
        return streams[current].hasNext();
    };

    return frozen self;
}

exported proc empty() {
    final self = Stream();

    self.next = proc() {
        throw "next element does not exist";
    };

    self.hasNext = proc() => false;

    return frozen self;
}

exported proc single(e) {
    final self = Stream();

    final buf = Buffer();
    buf.put(e);

    self.next = proc() {
        if !self.hasNext()  throw "next element does not exist";
        return buf.take();
    };

    self.hasNext = proc() => buf.has();

    return frozen self;
}